; 基本概念 : 全ては唯のデータである

; システムが評価していた(+ 10 20) はリストである。
; 第一要素が関数名や特別式であるだけで、それ以降の
; 要素を引数として認識させていただけである。

; (+ 10 20) や (set 'x 10) などの関数を実行するコマンド
; もリストであるので、変数として保存可能である。

; ＠list関数やsetq特別式で作成したリストはLISPシステムに渡され
;   ていたわけではなく、その関数が実行され結果が表示されていたのである。
;   => リストはどうやって実行する？

; eval関数 : リストを評価する組み込み関数
; (eval form)
; ＊LISPでは式のことをしばしばフォームと呼ぶ
; form : LISPシステムが評価できるあらゆるデータを指定可能

; 単純な数値や文字をフォームとして渡した場合
; => そのデータそのものが結果となる。

; 記号をフォームとして渡した場合
; => 単純にコマンドに数値や変数名を指定した場合と同じ

; リストをフォームとして渡した場合
; => 1.) evalはリストを式として評価し、実行する
; => 2.) evalが実行するリストは第一要素が関数名や記号で
;        それ以降の要素が引数となるようなもの。
;     ＠setqやquoteなどの場合は関数ではなく特別式として評価される


(setq x 100)
(format t "(eval 10) : ~A~A" (eval 10) #\LineFeed)

(format t "(eval x) : ~A~A" (eval x) #\LineFeed)

(format t "(eval '(+ 10 20)) : ~A~A" (eval (quote (+ 10 20))) #\LineFeed)


; eval関数で評価させるために、setqのコマンド列を実行させないままに
; そのまま文字列として渡す必要がある。そのためsetq特別式全体をquote特別式
; にぶち込んでeval関数に引き渡している。

(format t "(eval '(setq x '(10 20 30))) : ~A~A"
  (eval (quote (setq x (quote (10 20 30))))) #\LineFeed)

; ＊実行時にリストを評価できることで、実行時のコマンド生成や実行時の
; 　コマンドの変数化などが可能になる


(setq cmd_var (quote (+ 10 20 30 40)))

(princ (eval cmd_var))

(setq add (quote (+ x y)))

(setq x 150 y 250)

(print (eval add))

(setq x 100)

(print (eval add))
